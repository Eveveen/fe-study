## js 中的作用域与变量声明提升   
- 变量提升的表现：    
   可以在变量声明前访问到而不会报错；    
      
- 变量提升的原因：   
   js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。   
   当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，   
   而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，   
   它包含了函数的形参、所有的函数和变量声明，这个对象是在代码解析的时候创建的。


## let var const 的区别

1. var 声明的变量会挂载在 window 上，而 let 和 const 声明的变量不会
2. var 声明的变量存在变量提升，let 和 const 不存在
3. 同一作用域下 var 可以声明同名变量, let 和 const 不可以


## let 和 const 的注意点   
   
1. 声明的变量只在声明时的代码块内有效
2. 不存在声明提升
3. 存在暂时性死区，如果在变量声明前使用，会报错
4. 不允许重复声明，重复声明会报错
5. const 一旦声明必须赋值，不能用 null 占位，声明后不能再修改，如果声明的是复合类型数据，可以修改属性

题目
```js
for(var i = 0; i <= 3; i++){
 setTimeout(function() { 
  console.log(i) 
 }, 10);
} // 4
```
分别会输出什么？为什么？如何修改可以使其输出 0，1，2，3 ？
```js
// 法一：
for(var i = 0; i <= 3; i++){
  (function(i){
    setTimeout(function() { 
      console.log(i) 
    }, 10);
  })()
}

// 法二
for(let i = 0; i <= 3; i++){
 setTimeout(function() { 
  console.log(i) 
 }, 10);
}
```

- 题目输出 4 原因：
1. var 定义的变量是全局的，所以全局只有一个变量 i
2. setTimeout 是异步，在下一轮事件循环，等到执行的时候，去找变量 i 的引用。所以函数找到了遍历完后的 i, 此时它已经变成了 4


1. let 引入了块级作用域的概念，创建 setTimeout 函数时，变量 i 在作用域内。对于循环的每个迭代，引用的 i 是 i 的不同实例
2. var 存在变量提升的问题
3. const 在 let 的基础上，不可被修改 


## 下面这段代码会输出什么？为什么？
```
for (var i = 0; i < 5; ++i) { 
    setTimeout(() => console.log(i), 0) 
}
```

解答：
> 输出：5 5 5 5 5   
>   
> 退出循环时，迭代变量保存的是导致循环退出的值：5   
> 在之后执行超时逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值。   
>   
>   
> 若题中的 var 改为 let，则最终输出的结果为 0 1 2 3 4   
> 因为使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。   
> 每个 setTimeOut 应用的都是不同的变量实例，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。   