# HTTP

HTTP 协议是个⽆状态协议，不会保存状态。



## Post 和 Get 的区别

先引⼊副作⽤和幂等的概念。

副作⽤指对服务器上的资源做改变，搜索是⽆副作⽤的，注册是副作⽤的。



幂等指发送 M 和 N 次请求（两者不相同且都⼤于 1），服务器上资源的状态⼀致，⽐如注册

10 个和 11 个帐号是不幂等的，对⽂章进⾏更改 10 次和 11 次是幂等的。



在规范的应⽤场景上说，

Get 多⽤于⽆副作⽤，幂等的场景，例如搜索关键字。

Post 多⽤于副作⽤，不幂等的场景，例如注册。



在技术上说：

- Get 请求能缓存，Post 不能

- Post 相对 Get 安全⼀点点，因为Get 请求都包含在 URL ⾥，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是⼀样的。

- Post 可以通过 request body来传输⽐ Get 更多的数据，Get 没有这个技术
- URL有⻓度限制，会影响 Get 请求，但是这个⻓度限制是浏览器规定的，不是 RFC 规定的

- Post ⽀持更多的编码类型且不对数据类型限制



## 常⻅状态码

**2XX 成功**

200 OK，表示从客户端发来的请求在服务器端被正确处理

204 No content，表示请求成功，但响应报⽂不含实体的主体部分

205 Reset Content，表示请求成功，但响应报⽂不含实体的主体部分，但是与 204 响应不同在于要求请求⽅重置内容

206 Partial Content，进⾏范围请求



**3XX** **重定向**

301 moved permanently，永久性重定向，表示资源已被分配了新的 URL

302 found，临时性重定向，表示资源临时被分配了新的 URL

303 see other，表示资源存在着另⼀个 URL，应使⽤ GET ⽅法获取资源

304 not modified，表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况

307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求⽅法不

变向新的地址发出请求



**4XX** **客户端错误**

- 400 bad request，请求报⽂存在语法错误

- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息

- 403 forbidden，表示对请求资源的访问被服务器拒绝

- 404 not found，表示在服务器上没有找到请求的资源



**5XX** **服务器错误**

- 500 internal sever error，表示服务器端在执⾏请求时发⽣了错误

- 501 Not Implemented，表示服务器不⽀持当前请求所需要的某个功能

- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求



## HTTP 首部

**通⽤字段** 						**作⽤**

Cache-Control 			控制缓存的⾏为

Connection 				浏览器想要优先使⽤的连接类型，⽐如 keep-alive

Date 							创建报⽂时间

Pragma 						报⽂指令

Via 								代理服务器相关信息

Transfer-Encoding 	传输编码⽅式

Upgrade 					要求客户端升级协议

Warning 					在内容中可能存在错误



**请求字段** 						**作⽤**

Accept 							能正确接收的媒体类型

Accept-Charset 			能正确接收的字符集

Accept-Encoding 		能正确接收的编码格式列表

Accept-Language 		能正确接收的语⾔列表

Expect 							期待服务端的指定⾏为

From 							请求⽅邮箱地址

Host 								服务器的域名

If-Match 						两端资源标记⽐较

If-Modified-Since 		本地资源未修改返回 304（⽐较时间）

If-None-Match 			本地资源未修改返回 304（⽐较标记）

User-Agent 					客户端信息

Max-Forwards 			限制可被代理及⽹关转发的次数

Proxy-Authorization 	向代理服务器发送验证信息

Range 							请求某个内容的⼀部分

Referer 							表示浏览器所访问的前⼀个⻚⾯

TE 								传输编码⽅式





**请求字段** 				**作⽤**

Accept 					能正确接收的媒体类型

Accept-Charset 		能正确接收的字符集

Accept-Encoding 		能正确接收的编码格式列表

Accept-Language 		能正确接收的语⾔列表

Expect 							期待服务端的指定⾏为

From 							请求⽅邮箱地址

Host 							服务器的域名

If-Match 						两端资源标记⽐较

If-Modified-Since 		本地资源未修改返回 304（⽐较时间）

If-None-Match 			本地资源未修改返回 304（⽐较标记）

User-Agent 					客户端信息

Max-Forwards 			限制可被代理及⽹关转发的次数

Proxy-Authorization 	向代理服务器发送验证信息

Range 							请求某个内容的⼀部分

Referer 						表示浏览器所访问的前⼀个⻚⾯

TE 								传输编码⽅式





# HTTPS

HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进⾏了加密。



## TLS

TLS 协议位于传输层之上，应⽤层之下。⾸次进⾏ TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到⼀个 RTT。 



在 TLS 中使⽤了两种加密技术，分别为：对称加密和⾮对称加密。

**对称加密**：

对称加密就是两边拥有相同的秘钥，两边都知道如何将密⽂加密解密。



**⾮对称加密**：

有公钥私钥之分，公钥所有⼈都可以知道，可以将数据⽤公钥加密，但是将数据解密必须使⽤私钥解密，私钥只有分发公钥的⼀⽅才知道。



TLS 握⼿过程如下：
1. 客户端发送⼀个随机值，需要的协议和加密⽅式

2. 服务端收到客户端的随机值，⾃⼰也产⽣⼀个随机值，并根据客户端需求的协议和加密⽅式来使⽤对应的⽅式，发送⾃⼰的证书（如果需要验证客户端证书需要说明）

3. 客户端收到服务端的证书并验证是否有效，验证通过会再⽣成⼀个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书

4. 服务端收到加密过的随机值并使⽤私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密⽅式⽣成密钥，接下来的通信就可以通过该密钥来加密解密

  

通过以上步骤可知，在 TLS 握⼿阶段，两端使⽤⾮对称加密的⽅式来通信，但是因为⾮对称加密损耗的性能⽐对称加密⼤，所以在正式传输数据时，两端使⽤对称加密的⽅式通信。

PS：以上说明的都是 TLS 1.2 协议的握⼿情况，在 1.3 协议中，⾸次建⽴连接只需要⼀个RTT，后⾯恢复连接不需要 RTT 了。



**HTTP 2.0**

HTTP 2.0 相⽐于 HTTP 1.X，可以说是⼤幅度提⾼了 web 的性能。

在 HTTP 1.X 中，为了性能考虑，我们会引⼊雪碧图、将⼩图内联、使⽤多个域名等等的⽅式。这⼀切都是因为浏览器限制了同⼀个域名下的请求数量，当⻚⾯中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最⼤请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。



在 HTTP 2.0 中，引⼊了多路复⽤



## **⼆进制传输**

HTTP 2.0 中所有加强性能的核⼼点在于此。

在之前的 HTTP 版本中，我们是通过⽂本的⽅式传输数据。在 HTTP 2.0 中引⼊了新的编码机制，所有传输的数据都会被分割，并采⽤⼆进制格式编码。



## **多路复⽤**

在 HTTP 2.0 中，有两个⾮常重要的概念，分别是帧（frame）和流（stream）。



帧代表着最⼩的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。



多路复⽤，就是在⼀个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极⼤的提⾼传输性能。



## **Header** **压缩**

在 HTTP 1.X 中，我们使⽤⽂本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输⼏百到⼏千的字节。



在 HTTP 2.0 中，使⽤了 HPACK 压缩格式对传输的 header 进⾏编码，减少了 header 的⼤⼩。

并在两端维护了索引表，⽤于记录出现过的 header ，后⾯在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。



## **服务端** **Push**

在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。

可以想象以下情况，某些资源客户端是⼀定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少⼀点延迟时间。

当然在浏览器兼容的情况下你也可以使⽤ prefetch 



## **QUIC**

这是⼀个⾕歌出品的基于 UDP 实现的同为传输层的协议，⽬标很远⼤，希望替代 TCP 协议。

- 该协议⽀持多路复⽤，虽然 HTTP 2.0 也⽀持多路复⽤，但是下层仍是 TCP，因为 TCP的重传机制，只要⼀个包丢失就得判断丢失包并且重传，导致发⽣队头阻塞的问题，但是UDP 没有这个机制

- 实现了⾃⼰的加密协议，通过类似 TCP 的 TFO 机制可以实现 0-RTT，当然 TLS 1.3 已经实现了 0-RTT 了

- ⽀持重传和纠错机制（向前恢复），在只丢失⼀个包的情况下不需要重传，使⽤纠错机制恢复丢失的包
  - 纠错机制：通过异或的⽅式，算出发出去的数据的异或值并单独发出⼀个包，服务端在发现有⼀个包丢失的情况下，通过其他数据包和异或值包算出丢失包
  - 在丢失两个包或以上的情况就使⽤重传机制，因为算不出来了